import{_ as n,n as l,p as s,q as i,s as e,R as d,t as c,Z as a}from"./framework-4bf64526.js";const r={},o=a(`<p><em>最近整理的一份之前的学习笔记</em></p><h2 id="_1-概念" tabindex="-1"><a class="header-anchor" href="#_1-概念" aria-hidden="true">#</a> 1. 概念</h2><ul><li>线程是进程下一条条独立的执行路径</li><li>在程序运行时，即使没有自己创建线程，后台也会有多个线程（如主线程、gc线程等）</li><li>main()称之为主线程，是入口，用于执行整个程序</li><li>在一个进程中，如果开辟了多个线程，线程的运行由调度器安排调度，调度器是与操作系统紧密相关的，先后顺序是不能人为干预的；线程具有优先级，设置了优先级后，理论上优先级高的线程会被先执行</li><li>对同一份资源操作时，会存在资源抢夺的问题，需要加入并发控制</li><li>线程会带来额外开销（如CPU调度耗费的时间、并发控制的开销等）</li><li>每个线程只会与自己的工作内存交互，内存控制不当会造成数据不一致</li></ul><h2 id="_2-线程类的创建" tabindex="-1"><a class="header-anchor" href="#_2-线程类的创建" aria-hidden="true">#</a> 2. 线程类的创建</h2><p>共有三种创建方式</p><h3 id="_2-1-实现runnable接口" tabindex="-1"><a class="header-anchor" href="#_2-1-实现runnable接口" aria-hidden="true">#</a> 2.1 实现Runnable接口</h3><p>定义Runnable接口的实现类，实现run方法编写执行体。实例化实现类创建对象后，以该对象为构造参数创建Thread对象，并调用Thread对象下的start方法即可开启线程（代理思想）</p><p><strong>推荐使用这种方式：同一个Runnable实现类的对象可以被多个线程（Thread）使用</strong></p><h3 id="_2-2-继承thread类" tabindex="-1"><a class="header-anchor" href="#_2-2-继承thread类" aria-hidden="true">#</a> 2.2 继承Thread类</h3><p>定义Thread类的子类，重写run方法编写执行体。创建线程对象后，调用对象的start方法即可开启线程</p><p>Tip：Thread类实现了Runnable接口</p><p><strong>不推荐使用这种方式：单继承有局限性</strong></p><h3 id="_2-3-实现callable接口" tabindex="-1"><a class="header-anchor" href="#_2-3-实现callable接口" aria-hidden="true">#</a> 2.3 实现Callable接口</h3><ul><li>定义Callable接口的实现类，实现call方法（需要指定泛型为call方法的返回值类型），并创建出对象</li><li>创建执行服务（ExecutorService），常见的方式是“Executors.newFixedThreadPool(n)”（创建线程池）</li><li>提交执行：以Callable实现类的对象为参数调用执行服务（ExecutorService）下的submit方法</li><li>获取结果：ExecutorService的submit方法会返回线程的执行结果（Future对象），而该执行结果包含了Callable的call方法的返回值，使用get方法就可以获取</li><li>关闭执行服务：调用ExecutorService下的shutdownNow方法</li></ul><h2 id="_3-线程的五大状态" tabindex="-1"><a class="header-anchor" href="#_3-线程的五大状态" aria-hidden="true">#</a> 3. 线程的五大状态</h2><p><img src="https://s3.bmp.ovh/imgs/2022/05/17/b1f2f7038b971bfd.jpg" alt="202205170339484"></p><p>五大状态指的是概念上的状态：</p><ul><li>创建状态：线程对象（Thread）一旦被创建，就进入到了该状态</li><li>就绪状态：start方法被调用后，线程立即进入就绪状态（但并不意味着立即就被调度执行）</li><li>运行状态：线程被CPU调度运行时进入该状态，这时我们书写的代码块才会被执行</li><li>阻塞状态：当sleep、wait被调用或同步锁生效时，线程进入阻塞状态，此时代码不会继续往下执行。阻塞状态解除后，线程重新进入就绪状态，等待CPU的调度执行</li><li>死亡状态：线程中断或结束</li></ul><h2 id="_4-线程的观测状态" tabindex="-1"><a class="header-anchor" href="#_4-线程的观测状态" aria-hidden="true">#</a> 4. 线程的观测状态</h2><p>观测状态指的是实际代码中的状态（Thread.State枚举类中有所定义）：</p><table><thead><tr><th style="text-align:center;">名称</th><th style="text-align:center;">描述</th></tr></thead><tbody><tr><td style="text-align:center;">NEW</td><td style="text-align:center;">尚未启动的线程处于此状态</td></tr><tr><td style="text-align:center;">RUNNABLE</td><td style="text-align:center;">在Java虚拟机中执行的线程处于此状态</td></tr><tr><td style="text-align:center;">BLOCKED</td><td style="text-align:center;">被阻塞等待监视器锁定的线程处于此状态</td></tr><tr><td style="text-align:center;">WAITING</td><td style="text-align:center;">正在等待另一个线程执行特定动作的线程处于此状态（无限期等待）</td></tr><tr><td style="text-align:center;">TIMED_WAITING</td><td style="text-align:center;">正在等待另一个线程执行动作达到指定等待时间的线程处于此状态（过期不候）</td></tr><tr><td style="text-align:center;">TREMINATED</td><td style="text-align:center;">已退出的线程处于此状态</td></tr></tbody></table><p>调用线程对象的getState方法拿到当前线程的运行状态</p><h2 id="_5-线程方法" tabindex="-1"><a class="header-anchor" href="#_5-线程方法" aria-hidden="true">#</a> 5. 线程方法</h2><p><img src="https://s3.bmp.ovh/imgs/2022/05/17/63f2b7f25fbcf8c2.png" alt="202205170340431"></p><h2 id="_6-停止线程" tabindex="-1"><a class="header-anchor" href="#_6-停止线程" aria-hidden="true">#</a> 6. 停止线程</h2><p>JDK提供的stop、destroy方法都已经被官方弃用，不推荐使用</p><p>可以定义标志位，线程对外提供stop方法来更改这个标志位，并在run方法中检测这个标志位以判断是否应该继续执行该线程（也就是说，使run方法返回是线程结束的唯一方式）</p><h2 id="_7-线程休眠" tabindex="-1"><a class="header-anchor" href="#_7-线程休眠" aria-hidden="true">#</a> 7. 线程休眠</h2><p>使用sleep方法进行线程休眠：</p><ul><li>可以执行休眠进行的毫秒数</li><li>存在可能抛出的异常InterruptedException</li><li>sleep时间达到后，线程进入就绪状态</li><li>sleep不会释放锁</li></ul><h2 id="_8-线程礼让" tabindex="-1"><a class="header-anchor" href="#_8-线程礼让" aria-hidden="true">#</a> 8. 线程礼让</h2><p>使用yield进行线程礼让：</p><ul><li>当前正在执行的线程暂停，但不阻塞，线程会直接从运行状态转为就绪状态</li><li>进行礼让后，CPU会重新调度执行一条线程，然而有可能重新执行的这条线程就是之前进行礼让的线程，也就是说这个礼让不一定成功</li></ul><h2 id="_9-线程强制执行-插队" tabindex="-1"><a class="header-anchor" href="#_9-线程强制执行-插队" aria-hidden="true">#</a> 9. 线程强制执行（插队）</h2><p>使用join方法合并线程：</p><ul><li>调用join方法的线程执行时，其他线程会一直被阻塞（直到join线程执行完毕）</li><li>就类似插队</li></ul><h2 id="_10-守护线程" tabindex="-1"><a class="header-anchor" href="#_10-守护线程" aria-hidden="true">#</a> 10. 守护线程</h2><p>线程分为<strong>用户线程</strong>和<strong>守护线程</strong>：</p><ul><li>虚拟机必须确保用户线程执行完毕</li><li>虚拟机不用等待守护线程执行完毕（也就是说主线程结束，守护线程也不会结束，当然除非虚拟机关了）</li><li>后台记录操作日志、监控内存、垃圾回收等待等功能都是由守护线程来负责的</li></ul><p>想要线程从用户线程变为守护线程，调用setDaemon方法，设置为true即可</p><h2 id="_11-线程同步" tabindex="-1"><a class="header-anchor" href="#_11-线程同步" aria-hidden="true">#</a> 11. 线程同步</h2><p>由于同一进程的多个线程共享同一块存储空间，会存在访问冲突问题，为了保证数据在方法中被访问时的正确性，在访问时加入<strong>锁机制（synchronized）</strong>，当一个线程对象的排他锁，这时代表它正在独占共享资源，其他线程如果想要使用同一资源则需要等待，直到排他锁被释放：</p><ul><li>一个线程持有锁会导致其他所有需要此资源（锁）的线程挂起</li><li>在多线程竞争下，加锁和释放锁会导致比较多的上下文切换和调度延时，引起性能问题</li><li>优先级倒置问题：优先级低的线程占据着锁，导致优先级高的线程反而需要等待优先级低的线程释放锁</li></ul><h3 id="_11-1-同步方法" tabindex="-1"><a class="header-anchor" href="#_11-1-同步方法" aria-hidden="true">#</a> 11.1 同步方法</h3><p>使用<strong>synchronized</strong>关键字修饰方法即可让方法变为同步方法，每个对象对应一把锁，而所有的同步方法都必须获得其访问的对象的锁才能继续执行，获取不到则线程会一直阻塞等待，一旦获取到，就独占该锁，直到方法返回</p><p>如果synchronized修饰了普通方法，则锁的是this，如果修饰了静态方法，则锁的是Class模板（Clazz）</p><p><strong>普通方法不受锁的任何影响</strong></p><h3 id="_11-2-同步块" tabindex="-1"><a class="header-anchor" href="#_11-2-同步块" aria-hidden="true">#</a> 11.2 同步块</h3><p>语法格式：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">synchronized</span> <span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">// 代码块</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述代码中的“obj”被称为“<strong>同步监视器</strong>”：</p><ul><li>obj可以是任何对象，但推荐使用共享资源</li><li>其实同步方法和同步监视器的是相同的，同步方法就是将this指定为了同步监视器，即锁定的就是这个对象本身（或是clazz），因此如果我们不想把同步监视器设置为this，就不要使用同步方法，而是使用同步块，自己进行指定</li><li>同步监视器的执行过程（假设有两个线程）： <ol><li>第一个线程访问，锁定同步监视器，执行其中代码</li><li>第二个线程访问，发现同步监视器被锁定，无法访问，阻塞等待</li><li>第一个线程访问完毕，解锁同步监视器</li><li>第二个线程访问，发现同步监视器没有锁，于是锁定同步监视器，执行其中代码</li></ol></li></ul><h3 id="_11-3-cow容器" tabindex="-1"><a class="header-anchor" href="#_11-3-cow容器" aria-hidden="true">#</a> 11.3 COW容器</h3><p>在多线程的场景中，我们原本使用的很多容器都不能再使用了，以数组容器为例，我们常用的<code>ArrayList</code>线程不安全，使用时可以手动使用<code>synchronized</code>强行加锁同步，但长此以往，总归不是个办法</p><p>相比之下，<code>CopyOnWriteArrayList</code>是线程安全的，目前是多线程场景下较为常用的List容器</p><p><em>关于COW容器到这里就浅尝辄止了，如果你希望了解更多，可以看咱后续发布的JUC相关笔记</em></p><h3 id="_11-4-死锁" tabindex="-1"><a class="header-anchor" href="#_11-4-死锁" aria-hidden="true">#</a> 11.4 死锁</h3><p>多个线程各自占有一些共享资源，并且需要使用其他线程占有的资源，这时就导致了两个或者多个线程都在互相等待对方释放资源，此时它们都是阻塞状态，停止执行，谁都动不了，这就是死锁</p><h4 id="_11-4-1-避免方法" tabindex="-1"><a class="header-anchor" href="#_11-4-1-避免方法" aria-hidden="true">#</a> 11.4.1 避免方法</h4><p>死锁产生有四个必要条件：</p><ul><li>互斥条件：一个资源每次只能被一个进程调用</li><li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放</li><li>不剥夺条件：进程已获得的资源，在未使用完之前，不能强行剥夺</li><li>循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系</li></ul><p>针对上述四个条件，选择任意项进行针对，即可避免死锁发生</p><h3 id="_11-5-lock" tabindex="-1"><a class="header-anchor" href="#_11-5-lock" aria-hidden="true">#</a> 11.5 Lock</h3><p>从JDK5.0开始，Java提供了更强大的线程同步机制——通过显式定义同步锁对象（Lock）来实现同步</p><p><code>java.util.concurrent.locks.Lock</code>接口是控制多个线程对共享资源进行访问的工具，提供了对共享资源的独占访问，每次只能有一个线程对Lock对象加锁，而线程开始访问共享资源之前应先获得Lock对象</p><p><code>ReentrantLock</code>类实现了<code>Lock</code>接口，它拥有与<code>synchronized</code>相同的并发性和内存语义，在实现线程安全的控制中，比较常用的是<code>ReentrantLock</code>，它可以显示加锁、释放锁</p><p><strong>使用方式很简单，要操作共享资源时调用加锁方法，操作完成后调用解锁方法即可</strong></p><p><code>Lock</code>与<code>synchronized</code>对比：</p><table><thead><tr><th style="text-align:center;"></th><th style="text-align:center;">synchronized</th><th style="text-align:center;">Lock</th></tr></thead><tbody><tr><td style="text-align:center;"><strong>生效方式</strong></td><td style="text-align:center;">隐式锁，出了作用域自动释放</td><td style="text-align:center;">显示锁，需要手动调用方法开启和关闭</td></tr><tr><td style="text-align:center;"><strong>锁类型</strong></td><td style="text-align:center;">有代码块锁和方法锁</td><td style="text-align:center;">只有代码块锁</td></tr><tr><td style="text-align:center;"><strong>性能</strong></td><td style="text-align:center;">性能没有Lock好</td><td style="text-align:center;">JVM会花费更少的时间调度线程</td></tr><tr><td style="text-align:center;"><strong>扩展性</strong></td><td style="text-align:center;">无</td><td style="text-align:center;">是接口，因此具有不同的实现方式</td></tr></tbody></table><p>此外，如果同时使用这些同步方式，则优先级为：</p><p>Lock &gt; 同步代码块（此时已经进入了方法体，分配了相关资源） &gt; 同步方法（在方法体之外）</p><h2 id="_12-线程协作" tabindex="-1"><a class="header-anchor" href="#_12-线程协作" aria-hidden="true">#</a> 12. 线程协作</h2><h3 id="_12-1-线程通信" tabindex="-1"><a class="header-anchor" href="#_12-1-线程通信" aria-hidden="true">#</a> 12.1 线程通信</h3><p>Java提供了几个方法解决线程之间的通信问题：</p><table><thead><tr><th style="text-align:center;">方法名</th><th style="text-align:center;">作用</th></tr></thead><tbody><tr><td style="text-align:center;">wait()</td><td style="text-align:center;">表示线程一直等待，直到其他线程通知，锁会被释放</td></tr><tr><td style="text-align:center;">wait(long timeout)</td><td style="text-align:center;">指定等待的毫秒数</td></tr><tr><td style="text-align:center;">notify()</td><td style="text-align:center;">唤醒一个调用了wait()处于等待状态的线程</td></tr><tr><td style="text-align:center;">notifyAll()</td><td style="text-align:center;">唤醒同一个对象上所有调用wait()方法的线程，此时优先级高的线程会被优先调度</td></tr></tbody></table><p>以上方法均是Object类的方法，都只能在同步方法或者同步代码块中使用，否则会抛出异常<strong>InlegalMonitorStateException</strong></p><h3 id="_12-2-解决方案-生产者-消费者模式" tabindex="-1"><a class="header-anchor" href="#_12-2-解决方案-生产者-消费者模式" aria-hidden="true">#</a> 12.2 解决方案（生产者/消费者模式）</h3><h4 id="_12-2-1-管程法" tabindex="-1"><a class="header-anchor" href="#_12-2-1-管程法" aria-hidden="true">#</a> 12.2.1 管程法</h4><ul><li>生产者：负责生产数据的模块（可能是方法、对象、线程、进程）</li><li>消费者：负责处理数据的模块（可能是方法、对象、线程、进程）</li><li>缓冲区：消费者不能直接使用生产者的数据，他们之间会有一个缓冲区，生产者将数据放入缓冲区，消费者从缓冲区中取出数据</li></ul><h4 id="_12-2-2-信号灯法" tabindex="-1"><a class="header-anchor" href="#_12-2-2-信号灯法" aria-hidden="true">#</a> 12.2.2 信号灯法</h4><p>总的来说，信号灯法就是设置一个标志位来作为信号来提醒生产者和消费者，双方通过更改这个标志位，达到通信中传递信号提醒的目的</p><p>Tip：信号灯法就是让生产者让消费者围绕标志位做文章，而管程法需要消费者围绕缓冲区容器做文章</p><h2 id="_13-线程池" tabindex="-1"><a class="header-anchor" href="#_13-线程池" aria-hidden="true">#</a> 13. 线程池</h2><p>线程经常创建和销毁，会消耗很大的资源，因此我们通常提前创建好多个线程，将它们放入线程池中，使用时直接获取，使用完后放回池中等待下一次使用，这样可以节省资源</p><p>总结好处：</p><ul><li>提高响应速度（减少了创建新线程的时间）</li><li>降低资源消耗（重复利用线程池中线程，不需要每次都创建）</li><li>可以设置一些线程池的参数，便于线程管理，如： <ul><li>corePoolSize：核心池大小，即池内能最多放多少个线程</li><li>maximumPoolSize：最大线程数</li><li>keepAliveTime：线程没有任务时最多保持多长时间后会终止</li></ul></li></ul><h3 id="_13-1-使用" tabindex="-1"><a class="header-anchor" href="#_13-1-使用" aria-hidden="true">#</a> 13.1 使用</h3><p>JDK5+提供了线程池相关API：<code>ExecutorService</code>（执行服务）和<code>Executors</code>：</p><ul><li><code>ExecutorService</code>：真正的线程池接口，常见子类为<code>ThreadPoolExecutor</code>，常用方法如下： <ul><li>void execute(Runnable command)：执行任务/命令，没有返回值，一般用来执行Runnable</li><li>&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task)：执行任务，有返回值，一般用来执行Callable</li><li>void shutdown()：关闭线程池</li></ul></li><li><code>Executors</code>：工具类，也是线程池的工厂类，用于创建并返回不同类型的线程池</li></ul><p>在上面<a href="###%E5%AE%9E%E7%8E%B0Callable%E6%8E%A5%E5%8F%A3">线程类的创建的实现Callable接口方式</a>中有涉及，想要更多的细节，可以去翻阅手册</p><h2 id="_14-threadlocal" tabindex="-1"><a class="header-anchor" href="#_14-threadlocal" aria-hidden="true">#</a> 14. ThreadLocal</h2><h3 id="_14-1-简单介绍" tabindex="-1"><a class="header-anchor" href="#_14-1-简单介绍" aria-hidden="true">#</a> 14.1 简单介绍</h3><p><code>ThreadLocal</code>是JDK提供的用于存储线程专属变量的工具，它的功能和API都非常简单，就是实现了线程之间的变量的隔离，这里只介绍它的实现原理</p><p>实际上，每个线程都有自己的<code>ThreadLocalMap</code>，使用<code>ThreadLocal</code>时，JDK会首先根据当前线程（<code>Thread</code>）从一个Map中获取到当前线程所属的<code>ThreadLocalMap</code>，然后再通过我们所使用的<code>ThreadLocal</code>从当前线程的<code>ThreadLocalMap</code>中获取到所需的线程专属对象</p><p>说白了，原理就是Map的嵌套，最外层的Map由<code>Thread</code>为key，<code>ThreadLocalMap</code>为值，而里面的一层<code>ThreadLocalMap</code>由<code>ThreadLocal</code>为key，值就是我们所存储的对象</p><h3 id="_14-2-内存泄漏问题" tabindex="-1"><a class="header-anchor" href="#_14-2-内存泄漏问题" aria-hidden="true">#</a> 14.2 内存泄漏问题</h3><p>我们最关心的实际上是使用<code>ThreadLocal</code>不当导致的内存泄露问题，而<code>ThreadLocal</code>对其内部容器的清理以尽量避免内存泄露的做法也是其精髓所在</p><p>那么什么时候容易出现所谓的内存泄露问题呢？<strong>使用线程池的时候</strong></p><p>因为将线程池化后，我们通常不会再池子外部再创建新线程去使用了，只要线程池没有关闭，里面的核心线程就一直存在，而我们又可能在线程中不停地新建<code>ThreadLocal</code>来存储对象，最后又没有及时清理，这就会导致内存的使用量不断攀升，最终可能导致OOM问题</p><p>实际上JDK的开发者也考虑到了这一点，因此他们将<code>ThreadLocalMap</code>的键位，也就是<code>ThreadLocal</code>，按照弱引用来存储（<code>WeakReference&lt;ThreadLocal&lt;?&gt;&gt;</code>），尽可能使得它被GC回收</p><p>因此JDK的相关逻辑中经常会有针对<code>ThreadLocalMap</code>的key的null判断，如果发现key为null，说明GC时已经将这个键作为弱引用回收了，JDK如果检测到这一点，就会将这个空key对应的值也进行置空（null），以促进对值对象的垃圾回收</p><p>JDK通过自动检测回收<code>ThreadLocal</code>的机制无法完全避免内存泄漏的发生，因此作为JDK的使用者，我们如果不再需要使用某个<code>ThreadLocal</code>对象了，也一定要主动调用其<code>remove</code>方法，避免内存泄露</p><h3 id="_14-3-inheritablethreadlocal" tabindex="-1"><a class="header-anchor" href="#_14-3-inheritablethreadlocal" aria-hidden="true">#</a> 14.3 InheritableThreadLocal</h3><p>有时我们希望当前线程的<code>ThreadLocal</code>存储的值，在当前线程创建的子线程中也能够被获取到，JDK为此提供了<code>InheritableThreadLocal</code>，使用它可以就实现这个目的</p><p>使用这个类时要注意一点：<strong>父线程在实例化子线程对象（<code>Thread</code>）之前，必须先设置<code>InheritableThreadLocal</code>的值，如果先创建子线程，后设置值，则这个值子线程是获取不到的</strong></p><p>原理很简单，就是子线程对象被创建时，拷贝了父线程的继承版TL对象，从而实现的值共享，但是这种拷贝只在子线程的构造器中进行了一次，所以子线程实例化之后，父线程就无法与其继续共享新值了</p><h3 id="_14-4-transmittablethreadlocal" tabindex="-1"><a class="header-anchor" href="#_14-4-transmittablethreadlocal" aria-hidden="true">#</a> 14.4 TransmittableThreadLocal</h3><p>假设我们手头已经有子线程，想让父线程把值共享到现有的子线程中，由于<code>InheritableThreadLocal</code>的局限性，这是无法实现的，原生JDK中也没有其他的解决方案，但是这种需求又是极常见的——因为我们一般都会使用池化技术，线程池初始化的时候已经把线程都创建好了，我们又没办法控制上述过程，我们所需求的是<strong>线程池任务提交时，将此时的父线程的<code>ThreadLocal</code>值共享给异步执行该任务的子线程</strong>，这种场景下父子线程的值共享问题非常让人困扰</p><p><code>TransmittableThreadLocal</code>是阿里开源的工具，就帮助我们实现了上述目标</p>`,109),p={href:"https://github.com/alibaba/transmittable-thread-local/",target:"_blank",rel:"noopener noreferrer"},h=a(`<p><code>TransmittableThreadLocal</code>可以被当作<code>InheritableThreadLocal</code>进行常规使用，这是因为它继承自后者</p><p>最常见的使用场景示例如下：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">TransmittableThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> context <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TransmittableThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// =====================================================</span>

<span class="token comment">// 在父线程中设置</span>
context<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">&quot;value-set-in-parent&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token class-name">Runnable</span> task <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RunnableTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 额外的处理，生成修饰了的对象ttlRunnable</span>
<span class="token class-name">Runnable</span> ttlRunnable <span class="token operator">=</span> <span class="token class-name">TtlRunnable</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>
executorService<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span>ttlRunnable<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// =====================================================</span>

<span class="token comment">// Task中可以读取，值是&quot;value-set-in-parent&quot;</span>
<span class="token class-name">String</span> value <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>不难看出，核心就是通过<code>TtlRunnable.get(Runnable)</code>来修饰<code>Runnable</code>对象，将修饰后的对象提交到线程池，就可以实现我们想要的“随时”的父子线程值共享的效果</p><p><em>针对<code>Callable</code>，同样可以使用<code>TtlCallable</code>进行修饰，用法相同</em></p><p>延伸阅读：https://zhuanlan.zhihu.com/p/113388946</p>`,6);function u(b,g){const t=l("ExternalLinkIcon");return s(),i("div",null,[o,e("p",null,[e("a",p,[d("官方Github"),c(t)])]),h])}const k=n(r,[["render",u],["__file","062601.html.vue"]]);export{k as default};
