import{_ as e,p as a,q as t,Z as i}from"./framework-4bf64526.js";const s={},n=i(`<h2 id="一、前言" tabindex="-1"><a class="header-anchor" href="#一、前言" aria-hidden="true">#</a> 一、前言</h2><p>这篇文章为一部外网Git教学演讲的笔记，是一些概念性、偏僻、进阶的内容，较为零散。主要针对有Git使用经验的开发者，于初学者没有任何作用</p><p>本篇的内容属于浅尝辄止的课堂笔记，还需结合搜索引擎学习</p><h2 id="二、正文" tabindex="-1"><a class="header-anchor" href="#二、正文" aria-hidden="true">#</a> 二、正文</h2><h3 id="_1-commit" tabindex="-1"><a class="header-anchor" href="#_1-commit" aria-hidden="true">#</a> 1. commit</h3><h4 id="_1-1-介绍" tabindex="-1"><a class="header-anchor" href="#_1-1-介绍" aria-hidden="true">#</a> 1.1 介绍</h4><p>commit用来跟踪文件，包括：</p><ul><li>文件的路径</li><li>文件的权限</li><li>文件的内容</li></ul><p>值得一提的是，Git并不关心空目录，如果目录下没有文件，这个目录也会被Git无视</p><h4 id="_1-2-head" tabindex="-1"><a class="header-anchor" href="#_1-2-head" aria-hidden="true">#</a> 1.2 HEAD</h4><p>每个提交都会有一个唯一标识（哈希码校验和），且存在一个HEAD指针指向当前的提交，你随时可以将指针指向历史提交，将仓库中的内容回滚到那个时候</p><h3 id="_2-checkout" tabindex="-1"><a class="header-anchor" href="#_2-checkout" aria-hidden="true">#</a> 2. checkout</h3><p>基于当前提交，可以通过<code>checkout</code>创建出一个新的分支提交，或在已有分支之间切换</p><p>记住，Git的“分支”概念只是为了方便使用者去理解，而非真正存在什么分支结构。Git提出的“分支”，本质上是为了区别不同的提交，给它们分好类，方便管理</p><h3 id="_3-merge" tabindex="-1"><a class="header-anchor" href="#_3-merge" aria-hidden="true">#</a> 3. merge</h3><p><img src="https://s3.bmp.ovh/imgs/2023/05/23/cd9b932bb4de7d29.png" alt="image-20230523113921831"></p><h4 id="_3-1介绍" tabindex="-1"><a class="header-anchor" href="#_3-1介绍" aria-hidden="true">#</a> 3.1介绍</h4><p>合并（merge）时，Git主要为我们处理了“三向合并”问题，来自三个地方的内容将被自动解析、合并：</p><ul><li>BASE：是指要合并的两个分支，分叉时的历史提交，在这些提交之后，两个分支才真的分道扬镳。Git主要会为我们梳理出两个分支的公共基础分支</li><li>LOCAL：当前HEAD所在的本地分支</li><li>REMOTE：远程分支</li></ul><p>合并后，会自动创建一个新的提交，HEAD将会移动到最新的这个提交</p><h4 id="_3-2-快进式-合并" tabindex="-1"><a class="header-anchor" href="#_3-2-快进式-合并" aria-hidden="true">#</a> 3.2 “快进式”合并</h4><p>“快进式”（Fast Forward）合并发生在两个分支虽然分叉，但是其中一个分支完全没有新增过提交的情况</p><p>举个例子，A、B两个分支，B分支从来没有提交过代码，A分支进行了几次提交，这时合并A到B，Git就会采用快进式合并，将B的分支指针直接指向A的最终提交，达成合并效果</p><p>快进式合并是Git的一种优化措施，可以避免不必要的“三向合并”解析</p><h3 id="_4-tag" tabindex="-1"><a class="header-anchor" href="#_4-tag" aria-hidden="true">#</a> 4. tag</h3><p>如果我们希望标记一个提交，给它起一个有意义的名称，而不是使用简单的哈希码来标识它们，就可以使用tag（打标签）</p><p>每一个标签被创建时，都会创建一个不可变的指针</p><p>我们可以将方便地将HEAD指针指向某个tag</p><h3 id="_5-fetch-pull" tabindex="-1"><a class="header-anchor" href="#_5-fetch-pull" aria-hidden="true">#</a> 5. fetch/pull</h3><p>在checkout一个远程分支后，Git会在本地创建一个该分支的local副本，我们的一切修改都在这个local分支进行，该local分支的“上游”（upstream）就对应了那条远程分支，如<code>remote/origin/develop</code></p><p>当我们使用<code>fetch</code>时，我们不会将最新的远程分支中的数据拉到本地，而是查看远程分支的更新情况，明确远程分支是否有新提交，这可以帮助我们查看最新的远程分支的情况</p><p>当我们使用<code>pull</code>时，会将远程分支的数据拉到本地</p><h3 id="_6-diff-add" tabindex="-1"><a class="header-anchor" href="#_6-diff-add" aria-hidden="true">#</a> 6. diff/add</h3><p>创建一条提交并不是一个原子化的操作，它包含多个步骤，其中就经历了<code>diff</code>和<code>add</code></p><p>我们可以使用<code>diff</code>来查看工作区（当前）和暂存区中的数据的区别</p><p>如果确定没有问题，可以使用<code>add</code>来将工作区的数据添加到暂存区</p><h3 id="_7-reset" tabindex="-1"><a class="header-anchor" href="#_7-reset" aria-hidden="true">#</a> 7. reset</h3><p>reset可以移动HEAD指针到之前的commit，将已经commit的数据重新放回工作区，它通常用于撤销一些提交</p><h3 id="_8-stash" tabindex="-1"><a class="header-anchor" href="#_8-stash" aria-hidden="true">#</a> 8. stash</h3><p>stash可以将当前工作区的变化内容存入一个“盒子”，随时可以从盒子中恢复这些变化，而多个盒子之间，形成的是栈结构，也就是说，连续多次stash，恢复时可以按照后来居上的顺序</p><h3 id="_9-submodule" tabindex="-1"><a class="header-anchor" href="#_9-submodule" aria-hidden="true">#</a> 9. submodule</h3><p>GIt子模块，它的诞生背景实际上很简单：有一个父项目，一个子项目，它们虽然有联系，但是却分别保存在不同的仓库中</p><p>这时，我们就可以把子项目作为父项目的“submodule”，使用指令<code>git submodule add &lt;submodule_url&gt;</code></p><p>项目中会多出对应的子项目目录，还有<code>.gitmodules</code>文件，后者记录了Git子模块相关的信息</p><p>当子模块有过提交后，父模块会认为这个子模块发生了变化</p><h3 id="_10-log" tabindex="-1"><a class="header-anchor" href="#_10-log" aria-hidden="true">#</a> 10. log</h3><p>使用<code>git log</code>来获取提交日志列表</p><p>使用<code>git log --graph</code>来获取提交日志，这些日志会以ASCII表的形式输出为图结构</p><p>使用<code>git log A B ^C</code>：获取所有可达A、可达B，但是不可达C的提交链，示意图如下：</p><p>提交树是这样：</p><img src="https://s3.bmp.ovh/imgs/2023/05/23/ceae507e28dd831b.png" alt="image-20230523154419638" style="zoom:50%;"><p><code>log A B ^C</code>筛选后是这样：</p><img src="https://s3.bmp.ovh/imgs/2023/05/23/afd6cf13e300712b.png" alt="image-20230523154513352" style="zoom:50%;"><p>使用<code>git log --ancestry-path X..Y</code>来截取X到Y这一段提交链（不包括X），示意图如下：</p><p>提交树是这样：</p><img src="https://s3.bmp.ovh/imgs/2023/05/23/778f5b1c5dbf2585.png" alt="image-20230523155131559" style="zoom:50%;"><p><code>log --ancestry-path X..Y</code>筛选后是这样：</p><p><img src="https://s3.bmp.ovh/imgs/2023/05/23/9f8bda9e9aaac162.png" alt="image-20230523155225938"></p><p>使用<code>git log --follow file/path</code>来筛选出对特定文件进行更改的所有提交</p><p>使用<code>git log --oneline -3</code>来筛选出最近的3次提交，并分行展示</p><p>还有很多筛选方式，这里不一一列举</p><h3 id="_11-bisect" tabindex="-1"><a class="header-anchor" href="#_11-bisect" aria-hidden="true">#</a> 11. bisect</h3><p>bisect是Git提供的引导功能，用于通过等分法查找BUG，它很强大，但是使用较少</p><h2 id="三、高级" tabindex="-1"><a class="header-anchor" href="#三、高级" aria-hidden="true">#</a> 三、高级</h2><p>这里是一些更具技巧性的功能，需要使用者很明确地知道自己有什么目的，以及自己当前在做什么</p><h3 id="_12-revert" tabindex="-1"><a class="header-anchor" href="#_12-revert" aria-hidden="true">#</a> 12. revert</h3><p>对于Git来说，commit与commit之间没有任何联系，不存在什么“在当前commit的基础上撤销某个commit”，但是当我们真的有撤销某个提交的需求时，使用revert是解决方案之一</p><p>revert功能可以基于现有的commit进行反向提交，形成一个新的commit，从而冲掉指定commit所作出的更改</p><h3 id="_13-cherry-pick" tabindex="-1"><a class="header-anchor" href="#_13-cherry-pick" aria-hidden="true">#</a> 13. cherry-pick</h3><p>当我们不想使用merge将一个分支的所有内容合并到当前分支，而只是想把那条分支上的部分commit合并过来时，就可以使用cherry-pick</p><p><code>git cherry-pick &lt;commitHash&gt; ...</code>将指定commit合并到当前分支（会生成新的commit）</p><p><code>git cherry-pick &lt;branchName&gt;</code>将指定分支的最新一次commit合并到当前分支（会生成新的commit）</p><p><code>git cherry-pick &lt;commitHash0&gt;..&lt;commitHashN&gt;</code>将从0~N（不包括0）范围内的提交都合并到当前分支</p><p><code>git cherry-pick &lt;commitHash0&gt;^..&lt;commitHashN&gt;</code>将从将从0~N（包括0）范围内的提交都合并到当前分支</p><p><em>更多内容可以看这篇：https://ruanyifeng.com/blog/2020/04/git-cherry-pick.html</em></p><h3 id="_14-rebase" tabindex="-1"><a class="header-anchor" href="#_14-rebase" aria-hidden="true">#</a> 14. rebase</h3><p>分支合并时，除了使用merge外，还有另一个选择：<code>git pull --rebase</code></p><blockquote><p><img src="https://s3.bmp.ovh/imgs/2023/05/24/04188e2d1ab01317.png" alt="rebase-before"></p><p><img src="https://s3.bmp.ovh/imgs/2023/05/24/c6902bea453a098d.png" alt="rebase-after"></p><p><strong>官方原文解释（如果觉得看不懂可以直接看下一段）</strong>：当执行rebase操作时，git会从两个分支的共同祖先开始提取待变基分支上的修改，然后将待变基分支指向基分支的最新提交，最后将刚才提取的修改应用到基分支的最新提交的后面。</p><p><strong>结合例子解释</strong>：当在feature分支上执行git rebase master时，git会从master和feature的共同祖先B开始提取feature分支上的修改，也就是C和D两个提交，先提取到。然后将feature分支指向master分支的最新提交上，也就是M。最后把提取的C和D接到M后面，<strong>注意这里的接法，官方没说清楚，实际是会依次拿M和C、D内容分别比较，处理冲突后生成新的C’和D’</strong>。一定注意，这里新C’、D’和之前的C、D已经不一样了，是我们处理冲突后的新内容，feature指针自然最后也是指向D’</p><p><em>以上内容来自：https://blog.csdn.net/weixin_42310154/article/details/119004977</em></p></blockquote><h2 id="四、成为git专家" tabindex="-1"><a class="header-anchor" href="#四、成为git专家" aria-hidden="true">#</a> 四、成为Git专家</h2><h3 id="_1-使用命令行" tabindex="-1"><a class="header-anchor" href="#_1-使用命令行" aria-hidden="true">#</a> 1. 使用命令行</h3><p>根据教程中的观点，想要成为Git专家，你首先要做到通过命令行而不是工具来使用Git，原因如下：</p><ul><li>Git是专门为命令行打造的</li><li>一些这方面的工具通常是为了方便使用而生，它们可能有BUG、省略了一些功能、误导了一些概念，它们不是Git</li><li>掌握命令行中的Git后，你可以在任意的场景下发挥能力，而不需要受制于工具</li></ul><h3 id="_2-配置" tabindex="-1"><a class="header-anchor" href="#_2-配置" aria-hidden="true">#</a> 2. 配置</h3><p>Git的配置大家都不会陌生：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># ~/.gitconfig</span>
<span class="token punctuation">[</span>user<span class="token punctuation">]</span>
name <span class="token operator">=</span> Xiao Ming
email <span class="token operator">=</span> <span class="token number">123456</span>@qq.com
<span class="token punctuation">..</span>.
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>此外，如果是非Windows环境（Windows下有完善的Git Bash），还推荐配置Git prompts，它可以很方便地提示你Git相关的信息（比如当前位于哪个分支），为你节约很多时间</p><p>然后就是设置ssh密钥，可以使用<code>ssh-keygen</code></p><p>不要使用http拉取代码，每次都要输入密码，很麻烦</p><h3 id="_3-练习场" tabindex="-1"><a class="header-anchor" href="#_3-练习场" aria-hidden="true">#</a> 3. 练习场</h3><p>用如下命令给自己创建一个Git练习场，测试各种Git命令：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">git</span> init playground-game
<span class="token function">git</span> init <span class="token parameter variable">--bare</span> fake-remote
<span class="token builtin class-name">cd</span> playground-game
<span class="token function">git</span> remote <span class="token function">add</span> remote-name <span class="token punctuation">..</span>/fake-remote
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_4-日常连招" tabindex="-1"><a class="header-anchor" href="#_4-日常连招" aria-hidden="true">#</a> 4. 日常连招</h3><p>当你要提交代码：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">git</span> status							<span class="token comment"># 查看当前仓库状态</span>
<span class="token function">git</span> <span class="token function">diff</span>							<span class="token comment"># 查看你改动了什么东西</span>
<span class="token function">git</span> <span class="token function">add</span>								<span class="token comment"># 确认无误，将你的改动放入暂存区</span>
<span class="token function">git</span> commit <span class="token parameter variable">-m</span> <span class="token string">&quot;my commit message&quot;</span>	<span class="token comment"># 提交你的改动</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,94),d=[n];function c(r,o){return a(),t("div",null,d)}const h=e(s,[["render",c],["__file","052401.html.vue"]]);export{h as default};
